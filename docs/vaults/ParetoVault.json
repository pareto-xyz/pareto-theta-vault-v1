{
  "methods": {
    "MIN_LIQUIDITY()": {
      "stateMutability": "view",
      "code": "function MIN_LIQUIDITY() external view returns (uint256)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      },
      "notice": "Always keep a few units of both assets, used to create pools         The owner is responsible for providing this initial deposit         In fee computation, guarantee at least this amount is left in vault"
    },
    "TOKEN_NAME()": {
      "stateMutability": "view",
      "code": "function TOKEN_NAME() external view returns (string)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "string"
        }
      },
      "notice": "Name of the Pareto receipt token"
    },
    "TOKEN_SYMBOL()": {
      "stateMutability": "view",
      "code": "function TOKEN_SYMBOL() external view returns (string)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "string"
        }
      },
      "notice": "Symbol of the Pareto receipt token"
    },
    "allowance(address,address)": {
      "stateMutability": "view",
      "code": "function allowance(address owner, address spender) external view returns (uint256)",
      "inputs": {
        "owner": {
          "type": "address"
        },
        "spender": {
          "type": "address"
        }
      },
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      },
      "details": "See {IERC20-allowance}."
    },
    "approve(address,uint256)": {
      "stateMutability": "nonpayable",
      "code": "function approve(address spender, uint256 amount) external nonpayable returns (bool)",
      "inputs": {
        "spender": {
          "type": "address"
        },
        "amount": {
          "type": "uint256"
        }
      },
      "outputs": {
        "_0": {
          "type": "bool"
        }
      },
      "details": "See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."
    },
    "balanceOf(address)": {
      "stateMutability": "view",
      "code": "function balanceOf(address account) external view returns (uint256)",
      "inputs": {
        "account": {
          "type": "address"
        }
      },
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      },
      "details": "See {IERC20-balanceOf}."
    },
    "completeWithdraw()": {
      "stateMutability": "nonpayable",
      "code": "function completeWithdraw() external nonpayable",
      "inputs": {},
      "outputs": {},
      "notice": "Completes a requested withdraw from past round."
    },
    "decimals()": {
      "stateMutability": "view",
      "code": "function decimals() external view returns (uint8)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint8"
        }
      },
      "details": "Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."
    },
    "decreaseAllowance(address,uint256)": {
      "stateMutability": "nonpayable",
      "code": "function decreaseAllowance(address spender, uint256 subtractedValue) external nonpayable returns (bool)",
      "inputs": {
        "spender": {
          "type": "address"
        },
        "subtractedValue": {
          "type": "uint256"
        }
      },
      "outputs": {
        "_0": {
          "type": "bool"
        }
      },
      "details": "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."
    },
    "deployVault()": {
      "stateMutability": "nonpayable",
      "code": "function deployVault() external nonpayable",
      "inputs": {},
      "outputs": {},
      "notice": "Sets up the vault condition on the current vault"
    },
    "deposit(uint256)": {
      "stateMutability": "nonpayable",
      "code": "function deposit(uint256 riskyAmount) external nonpayable",
      "inputs": {
        "riskyAmount": {
          "type": "uint256",
          "description": "is the amount of risky asset to deposit"
        }
      },
      "outputs": {},
      "notice": "Deposits risky asset from msg.sender."
    },
    "depositReceipts(address)": {
      "stateMutability": "view",
      "code": "function depositReceipts(address) external view returns (uint16 round, uint104 riskyToDeposit, uint128 ownedShares)",
      "inputs": {
        "_0": {
          "type": "address"
        }
      },
      "outputs": {
        "round": {
          "type": "uint16"
        },
        "riskyToDeposit": {
          "type": "uint104"
        },
        "ownedShares": {
          "type": "uint128"
        }
      }
    },
    "feeRecipient()": {
      "stateMutability": "view",
      "code": "function feeRecipient() external view returns (address)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "address",
          "description": "Address of the fee recipient"
        }
      },
      "notice": "Recipient of the fees charged each rollover"
    },
    "getAccountBalance(address)": {
      "stateMutability": "view",
      "code": "function getAccountBalance(address account) external view returns (uint256 riskyAmount, uint256 stableAmount)",
      "inputs": {
        "account": {
          "type": "address",
          "description": "is the address to lookup balance for"
        }
      },
      "outputs": {
        "riskyAmount": {
          "type": "uint256",
          "description": "is the risky asset owned by the vault for the user"
        },
        "stableAmount": {
          "type": "uint256",
          "description": "is the stable asset owned by the vault for the user"
        }
      },
      "notice": "Returns the asset balance held in the vault for one account"
    },
    "getAccountShares(address)": {
      "stateMutability": "view",
      "code": "function getAccountShares(address account) external view returns (uint256 shares)",
      "inputs": {
        "account": {
          "type": "address",
          "description": "is the address to lookup balance for"
        }
      },
      "outputs": {
        "shares": {
          "type": "uint256",
          "description": "is the share balance for the account"
        }
      },
      "notice": "Returns the number of shares (+unredeemed shares) for one account"
    },
    "increaseAllowance(address,uint256)": {
      "stateMutability": "nonpayable",
      "code": "function increaseAllowance(address spender, uint256 addedValue) external nonpayable returns (bool)",
      "inputs": {
        "spender": {
          "type": "address"
        },
        "addedValue": {
          "type": "uint256"
        }
      },
      "outputs": {
        "_0": {
          "type": "bool"
        }
      },
      "details": "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."
    },
    "initRounds(uint256)": {
      "stateMutability": "nonpayable",
      "code": "function initRounds(uint256 numRounds) external nonpayable",
      "inputs": {
        "numRounds": {
          "type": "uint256",
          "description": "is the number of rounds to initialize in the map"
        }
      },
      "outputs": {},
      "notice": "Save gas for writing values into the roundSharePriceIn(Risky/Stable) map",
      "details": "Writing 1 makes subsequent writes warm, reducing the gas from 20k to 5k"
    },
    "keeper()": {
      "stateMutability": "view",
      "code": "function keeper() external view returns (address)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "address",
          "description": "Address of the keeper"
        }
      },
      "notice": "Keeper who manually managers contract"
    },
    "managementFee()": {
      "stateMutability": "view",
      "code": "function managementFee() external view returns (uint256)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      }
    },
    "managerState()": {
      "stateMutability": "view",
      "code": "function managerState() external view returns (uint128 manualStrike, uint16 manualStrikeRound, uint32 manualVolatility, uint16 manualVolatilityRound, uint32 manualGamma, uint16 manualGammaRound)",
      "inputs": {},
      "outputs": {
        "manualStrike": {
          "type": "uint128"
        },
        "manualStrikeRound": {
          "type": "uint16"
        },
        "manualVolatility": {
          "type": "uint32"
        },
        "manualVolatilityRound": {
          "type": "uint16"
        },
        "manualGamma": {
          "type": "uint32"
        },
        "manualGammaRound": {
          "type": "uint16"
        }
      }
    },
    "name()": {
      "stateMutability": "view",
      "code": "function name() external view returns (string)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "string"
        }
      },
      "details": "Returns the name of the token."
    },
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
      "stateMutability": "nonpayable",
      "code": "function onERC1155BatchReceived(address, address, uint256[], uint256[], bytes) external nonpayable returns (bytes4)",
      "inputs": {
        "_0": {
          "type": "address"
        },
        "_1": {
          "type": "address"
        },
        "_2": {
          "type": "uint256[]"
        },
        "_3": {
          "type": "uint256[]"
        },
        "_4": {
          "type": "bytes"
        }
      },
      "outputs": {
        "_0": {
          "type": "bytes4"
        }
      }
    },
    "onERC1155Received(address,address,uint256,uint256,bytes)": {
      "stateMutability": "nonpayable",
      "code": "function onERC1155Received(address, address, uint256, uint256, bytes) external nonpayable returns (bytes4)",
      "inputs": {
        "_0": {
          "type": "address"
        },
        "_1": {
          "type": "address"
        },
        "_2": {
          "type": "uint256"
        },
        "_3": {
          "type": "uint256"
        },
        "_4": {
          "type": "bytes"
        }
      },
      "outputs": {
        "_0": {
          "type": "bytes4"
        }
      }
    },
    "owner()": {
      "stateMutability": "view",
      "code": "function owner() external view returns (address)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "address"
        }
      },
      "details": "Returns the address of the current owner."
    },
    "pendingWithdraw(address)": {
      "stateMutability": "view",
      "code": "function pendingWithdraw(address) external view returns (uint16 round, uint128 shares)",
      "inputs": {
        "_0": {
          "type": "address"
        }
      },
      "outputs": {
        "round": {
          "type": "uint16"
        },
        "shares": {
          "type": "uint128"
        }
      }
    },
    "performanceFee()": {
      "stateMutability": "view",
      "code": "function performanceFee() external view returns (uint256)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      }
    },
    "poolState()": {
      "stateMutability": "view",
      "code": "function poolState() external view returns (bytes32 nextPoolId, bytes32 currPoolId, uint256 currLiquidity, struct Vault.PoolParams currPoolParams, struct Vault.PoolParams nextPoolParams, uint32 nextPoolReadyAt)",
      "inputs": {},
      "outputs": {
        "nextPoolId": {
          "type": "bytes32"
        },
        "currPoolId": {
          "type": "bytes32"
        },
        "currLiquidity": {
          "type": "uint256"
        },
        "currPoolParams": {
          "type": "Vault.PoolParams"
        },
        "nextPoolParams": {
          "type": "Vault.PoolParams"
        },
        "nextPoolReadyAt": {
          "type": "uint32"
        }
      }
    },
    "primitiveParams()": {
      "stateMutability": "view",
      "code": "function primitiveParams() external view returns (address manager, address engine, address factory, uint8 decimals)",
      "inputs": {},
      "outputs": {
        "manager": {
          "type": "address"
        },
        "engine": {
          "type": "address"
        },
        "factory": {
          "type": "address"
        },
        "decimals": {
          "type": "uint8"
        }
      }
    },
    "renounceOwnership()": {
      "stateMutability": "nonpayable",
      "code": "function renounceOwnership() external nonpayable",
      "inputs": {},
      "outputs": {},
      "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
    },
    "requestWithdraw(uint256)": {
      "stateMutability": "nonpayable",
      "code": "function requestWithdraw(uint256 shares) external nonpayable",
      "inputs": {
        "shares": {
          "type": "uint256",
          "description": "is the number of shares to withdraw"
        }
      },
      "outputs": {},
      "notice": "Requests a withdraw that is processed after the current round"
    },
    "risky()": {
      "stateMutability": "view",
      "code": "function risky() external view returns (address)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "address",
          "description": "Address of the risky token contract"
        }
      },
      "notice": "Risky token of the risky / stable pair"
    },
    "rollover()": {
      "stateMutability": "nonpayable",
      "code": "function rollover() external nonpayable",
      "inputs": {},
      "outputs": {},
      "notice": "Rolls the vault's funds into the next vault         Performs rebalancing of vault asseets         Deposits tokens into new Primitive pool         Pending assets get counted into locked here"
    },
    "roundSharePriceInRisky(uint256)": {
      "stateMutability": "view",
      "code": "function roundSharePriceInRisky(uint256) external view returns (uint256)",
      "inputs": {
        "_0": {
          "type": "uint256"
        }
      },
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      }
    },
    "roundSharePriceInStable(uint256)": {
      "stateMutability": "view",
      "code": "function roundSharePriceInStable(uint256) external view returns (uint256)",
      "inputs": {
        "_0": {
          "type": "uint256"
        }
      },
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      }
    },
    "seedVault()": {
      "stateMutability": "nonpayable",
      "code": "function seedVault() external nonpayable",
      "inputs": {},
      "outputs": {},
      "notice": "Seeds vault with minimum funding",
      "details": "Requires approval by owner to contract of at least MIN_LIQUIDITY      This is used to satisfy the minimum liquidity to start RMM-01 pools      At least this liquidity will always remain in the vault      regardless of withdrawals or fee transfers"
    },
    "setFeeRecipient(address)": {
      "stateMutability": "nonpayable",
      "code": "function setFeeRecipient(address newFeeRecipient) external nonpayable",
      "inputs": {
        "newFeeRecipient": {
          "type": "address",
          "description": "is the address of the new fee recipient"
        }
      },
      "outputs": {},
      "notice": "Sets the fee recipient"
    },
    "setGamma(uint32)": {
      "stateMutability": "nonpayable",
      "code": "function setGamma(uint32 gamma) external nonpayable",
      "inputs": {
        "gamma": {
          "type": "uint32",
          "description": "is 1-fee of the new pool. Important for replication"
        }
      },
      "outputs": {},
      "notice": "Optionality to manually set gamma"
    },
    "setKeeper(address)": {
      "stateMutability": "nonpayable",
      "code": "function setKeeper(address newKeeper) external nonpayable",
      "inputs": {
        "newKeeper": {
          "type": "address",
          "description": "is the address of the new keeper"
        }
      },
      "outputs": {},
      "notice": "Sets the keeper"
    },
    "setManagementFee(uint256)": {
      "stateMutability": "nonpayable",
      "code": "function setManagementFee(uint256 newManagementFee) external nonpayable",
      "inputs": {
        "newManagementFee": {
          "type": "uint256",
          "description": "is the management fee"
        }
      },
      "outputs": {},
      "notice": "Sets the management fee for the vault"
    },
    "setPerformanceFee(uint256)": {
      "stateMutability": "nonpayable",
      "code": "function setPerformanceFee(uint256 newPerformanceFee) external nonpayable",
      "inputs": {
        "newPerformanceFee": {
          "type": "uint256",
          "description": "is the performance fee"
        }
      },
      "outputs": {},
      "notice": "Sets the performance fee for the vault"
    },
    "setStrikePrice(uint128)": {
      "stateMutability": "nonpayable",
      "code": "function setStrikePrice(uint128 strikePrice) external nonpayable",
      "inputs": {
        "strikePrice": {
          "type": "uint128",
          "description": "is the strike price of the new pool"
        }
      },
      "outputs": {},
      "notice": "Optionality to manually set strike price"
    },
    "setUniswapPoolFee(uint24)": {
      "stateMutability": "nonpayable",
      "code": "function setUniswapPoolFee(uint24 newPoolFee) external nonpayable",
      "inputs": {
        "newPoolFee": {
          "type": "uint24",
          "description": "is the new pool fee"
        }
      },
      "outputs": {},
      "notice": "Sets the fee to search for when routing"
    },
    "setVaultManager(address)": {
      "stateMutability": "nonpayable",
      "code": "function setVaultManager(address newVaultManager) external nonpayable",
      "inputs": {
        "newVaultManager": {
          "type": "address",
          "description": "is the address of the new manager contract"
        }
      },
      "outputs": {},
      "notice": "Sets the new Vault Manager contract"
    },
    "setVolatility(uint32)": {
      "stateMutability": "nonpayable",
      "code": "function setVolatility(uint32 volatility) external nonpayable",
      "inputs": {
        "volatility": {
          "type": "uint32",
          "description": "is the sigma of the new pool"
        }
      },
      "outputs": {},
      "notice": "Optionality to manually set implied volatility"
    },
    "stable()": {
      "stateMutability": "view",
      "code": "function stable() external view returns (address)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "address",
          "description": "Address of the stable token contract"
        }
      },
      "notice": "Stable token of the risky / stable pair"
    },
    "supportsInterface(bytes4)": {
      "stateMutability": "view",
      "code": "function supportsInterface(bytes4 interfaceId) external view returns (bool)",
      "inputs": {
        "interfaceId": {
          "type": "bytes4"
        }
      },
      "outputs": {
        "_0": {
          "type": "bool"
        }
      },
      "details": "See {IERC165-supportsInterface}."
    },
    "symbol()": {
      "stateMutability": "view",
      "code": "function symbol() external view returns (string)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "string"
        }
      },
      "details": "Returns the symbol of the token, usually a shorter version of the name."
    },
    "tokenParams()": {
      "stateMutability": "view",
      "code": "function tokenParams() external view returns (address risky, address stable, uint8 riskyDecimals, uint8 stableDecimals)",
      "inputs": {},
      "outputs": {
        "risky": {
          "type": "address"
        },
        "stable": {
          "type": "address"
        },
        "riskyDecimals": {
          "type": "uint8"
        },
        "stableDecimals": {
          "type": "uint8"
        }
      }
    },
    "totalRisky()": {
      "stateMutability": "view",
      "code": "function totalRisky() external view returns (uint256)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      },
      "notice": "Return vault's total balance of risky assets, including         amounts locked into Primitive"
    },
    "totalStable()": {
      "stateMutability": "view",
      "code": "function totalStable() external view returns (uint256)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      },
      "notice": "Return vault's total balance of stable assets, including         amounts locked into Primitive"
    },
    "totalSupply()": {
      "stateMutability": "view",
      "code": "function totalSupply() external view returns (uint256)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      },
      "details": "See {IERC20-totalSupply}."
    },
    "transfer(address,uint256)": {
      "stateMutability": "nonpayable",
      "code": "function transfer(address to, uint256 amount) external nonpayable returns (bool)",
      "inputs": {
        "to": {
          "type": "address"
        },
        "amount": {
          "type": "uint256"
        }
      },
      "outputs": {
        "_0": {
          "type": "bool"
        }
      },
      "details": "See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."
    },
    "transferFrom(address,address,uint256)": {
      "stateMutability": "nonpayable",
      "code": "function transferFrom(address from, address to, uint256 amount) external nonpayable returns (bool)",
      "inputs": {
        "from": {
          "type": "address"
        },
        "to": {
          "type": "address"
        },
        "amount": {
          "type": "uint256"
        }
      },
      "outputs": {
        "_0": {
          "type": "bool"
        }
      },
      "details": "See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."
    },
    "transferOwnership(address)": {
      "stateMutability": "nonpayable",
      "code": "function transferOwnership(address newOwner) external nonpayable",
      "inputs": {
        "newOwner": {
          "type": "address"
        }
      },
      "outputs": {},
      "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
    },
    "uniswapParams()": {
      "stateMutability": "view",
      "code": "function uniswapParams() external view returns (address router, uint24 poolFee)",
      "inputs": {},
      "outputs": {
        "router": {
          "type": "address"
        },
        "poolFee": {
          "type": "uint24"
        }
      }
    },
    "vaultManager()": {
      "stateMutability": "view",
      "code": "function vaultManager() external view returns (address)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "address",
          "description": "Address of the ParetoManager contract"
        }
      },
      "notice": "ParetoManager contract used to specify options"
    },
    "vaultState()": {
      "stateMutability": "view",
      "code": "function vaultState() external view returns (uint16 round, uint104 lockedRisky, uint104 lockedStable, uint104 lastLockedRisky, uint104 lastLockedStable, uint128 pendingRisky, uint256 lastQueuedWithdrawRisky, uint256 lastQueuedWithdrawStable, uint256 currQueuedWithdrawShares, uint256 totalQueuedWithdrawShares)",
      "inputs": {},
      "outputs": {
        "round": {
          "type": "uint16"
        },
        "lockedRisky": {
          "type": "uint104"
        },
        "lockedStable": {
          "type": "uint104"
        },
        "lastLockedRisky": {
          "type": "uint104"
        },
        "lastLockedStable": {
          "type": "uint104"
        },
        "pendingRisky": {
          "type": "uint128"
        },
        "lastQueuedWithdrawRisky": {
          "type": "uint256"
        },
        "lastQueuedWithdrawStable": {
          "type": "uint256"
        },
        "currQueuedWithdrawShares": {
          "type": "uint256"
        },
        "totalQueuedWithdrawShares": {
          "type": "uint256"
        }
      }
    }
  },
  "events": {
    "Approval": {
      "code": "event Approval(address indexed owner, address indexed spender, uint256 value)",
      "inputs": {
        "owner": {
          "type": "address",
          "indexed": true
        },
        "spender": {
          "type": "address",
          "indexed": true
        },
        "value": {
          "type": "uint256",
          "indexed": false
        }
      }
    },
    "ClosePositionEvent": {
      "code": "event ClosePositionEvent(bytes32 poolId, uint256 burnLiquidity, uint256 riskyAmount, uint256 stableAmount, address indexed keeper)",
      "inputs": {
        "poolId": {
          "type": "bytes32",
          "indexed": false
        },
        "burnLiquidity": {
          "type": "uint256",
          "indexed": false
        },
        "riskyAmount": {
          "type": "uint256",
          "indexed": false
        },
        "stableAmount": {
          "type": "uint256",
          "indexed": false
        },
        "keeper": {
          "type": "address",
          "indexed": true
        }
      },
      "notice": "Emitted when keeper burns RMM-01 LP tokens for assets"
    },
    "DeployVaultEvent": {
      "code": "event DeployVaultEvent(bytes32 poolId, uint128 strikePrice, uint32 volatility, uint32 gamma, address indexed keeper)",
      "inputs": {
        "poolId": {
          "type": "bytes32",
          "indexed": false
        },
        "strikePrice": {
          "type": "uint128",
          "indexed": false
        },
        "volatility": {
          "type": "uint32",
          "indexed": false
        },
        "gamma": {
          "type": "uint32",
          "indexed": false
        },
        "keeper": {
          "type": "address",
          "indexed": true
        }
      },
      "notice": "Emitted when keeper creates a new RMM-01 pool"
    },
    "DepositEvent": {
      "code": "event DepositEvent(address indexed account, uint256 riskyAmount, uint16 round)",
      "inputs": {
        "account": {
          "type": "address",
          "indexed": true
        },
        "riskyAmount": {
          "type": "uint256",
          "indexed": false
        },
        "round": {
          "type": "uint16",
          "indexed": false
        }
      },
      "notice": "Emitted when user deposits risky asset into vault"
    },
    "FeeRecipientSetEvent": {
      "code": "event FeeRecipientSetEvent(address indexed keeper)",
      "inputs": {
        "keeper": {
          "type": "address",
          "indexed": true
        }
      },
      "notice": "Emitted when owner sets new recipient address for fees"
    },
    "GammaSetEvent": {
      "code": "event GammaSetEvent(uint32 gamma, uint16 round)",
      "inputs": {
        "gamma": {
          "type": "uint32",
          "indexed": false
        },
        "round": {
          "type": "uint16",
          "indexed": false
        }
      },
      "notice": "Emitted when keeper manually sets next round's trading fee"
    },
    "KeeperSetEvent": {
      "code": "event KeeperSetEvent(address indexed keeper)",
      "inputs": {
        "keeper": {
          "type": "address",
          "indexed": true
        }
      },
      "notice": "Emitted when owner sets new keeper address"
    },
    "ManagementFeeSetEvent": {
      "code": "event ManagementFeeSetEvent(uint256 managementFee, uint256 newManagementFee)",
      "inputs": {
        "managementFee": {
          "type": "uint256",
          "indexed": false
        },
        "newManagementFee": {
          "type": "uint256",
          "indexed": false
        }
      },
      "notice": "Emitted when owner sets new management fee"
    },
    "OpenPositionEvent": {
      "code": "event OpenPositionEvent(bytes32 poolId, uint256 riskyAmount, uint256 stableAmount, uint256 returnLiquidity, address indexed keeper)",
      "inputs": {
        "poolId": {
          "type": "bytes32",
          "indexed": false
        },
        "riskyAmount": {
          "type": "uint256",
          "indexed": false
        },
        "stableAmount": {
          "type": "uint256",
          "indexed": false
        },
        "returnLiquidity": {
          "type": "uint256",
          "indexed": false
        },
        "keeper": {
          "type": "address",
          "indexed": true
        }
      },
      "notice": "Emitted when keeper deposits vault assets into RMM-01 pool"
    },
    "OwnershipTransferred": {
      "code": "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)",
      "inputs": {
        "previousOwner": {
          "type": "address",
          "indexed": true
        },
        "newOwner": {
          "type": "address",
          "indexed": true
        }
      }
    },
    "PerformanceFeeSetEvent": {
      "code": "event PerformanceFeeSetEvent(uint256 performanceFee, uint256 newPerformanceFee)",
      "inputs": {
        "performanceFee": {
          "type": "uint256",
          "indexed": false
        },
        "newPerformanceFee": {
          "type": "uint256",
          "indexed": false
        }
      },
      "notice": "Emitted when owner sets new performance fee"
    },
    "RebalanceVaultEvent": {
      "code": "event RebalanceVaultEvent(uint256 initialRisky, uint256 initialStable, uint256 optimalRisky, uint256 optimalStable, address indexed keeper)",
      "inputs": {
        "initialRisky": {
          "type": "uint256",
          "indexed": false,
          "description": "/Stable are the amounts of each token pre-rebalancing"
        },
        "initialStable": {
          "type": "uint256",
          "indexed": false
        },
        "optimalRisky": {
          "type": "uint256",
          "indexed": false,
          "description": "/Stable are the amounts of each token post-rebalancing"
        },
        "optimalStable": {
          "type": "uint256",
          "indexed": false
        },
        "keeper": {
          "type": "address",
          "indexed": true
        }
      },
      "notice": "Emitted as an internal step in rollover"
    },
    "StrikePriceSetEvent": {
      "code": "event StrikePriceSetEvent(uint128 strikePrice, uint16 round)",
      "inputs": {
        "strikePrice": {
          "type": "uint128",
          "indexed": false
        },
        "round": {
          "type": "uint16",
          "indexed": false
        }
      },
      "notice": "Emitted when keeper manually sets next round's strike price"
    },
    "Transfer": {
      "code": "event Transfer(address indexed from, address indexed to, uint256 value)",
      "inputs": {
        "from": {
          "type": "address",
          "indexed": true
        },
        "to": {
          "type": "address",
          "indexed": true
        },
        "value": {
          "type": "uint256",
          "indexed": false
        }
      }
    },
    "VaultFeesCollectionEvent": {
      "code": "event VaultFeesCollectionEvent(uint256 feeInRisky, uint256 feeInStable, uint16 round, address indexed feeRecipient)",
      "inputs": {
        "feeInRisky": {
          "type": "uint256",
          "indexed": false
        },
        "feeInStable": {
          "type": "uint256",
          "indexed": false
        },
        "round": {
          "type": "uint16",
          "indexed": false
        },
        "feeRecipient": {
          "type": "address",
          "indexed": true
        }
      },
      "notice": "Emitted when fees are transfered to feeRecipient"
    },
    "VaultManagerSetEvent": {
      "code": "event VaultManagerSetEvent(address indexed vaultManager)",
      "inputs": {
        "vaultManager": {
          "type": "address",
          "indexed": true
        }
      },
      "notice": "Emitted when owner sets new vault manager contract"
    },
    "VolatilitySetEvent": {
      "code": "event VolatilitySetEvent(uint32 volatility, uint16 round)",
      "inputs": {
        "volatility": {
          "type": "uint32",
          "indexed": false
        },
        "round": {
          "type": "uint16",
          "indexed": false
        }
      },
      "notice": "Emitted when keeper manually sets next round's implied volality"
    },
    "WithdrawCompleteEvent": {
      "code": "event WithdrawCompleteEvent(address indexed account, uint256 shares, uint256 riskyAmount, uint256 stableAmount)",
      "inputs": {
        "account": {
          "type": "address",
          "indexed": true
        },
        "shares": {
          "type": "uint256",
          "indexed": false
        },
        "riskyAmount": {
          "type": "uint256",
          "indexed": false
        },
        "stableAmount": {
          "type": "uint256",
          "indexed": false
        }
      },
      "notice": "Emitted when user's queued withdrawal is complete"
    },
    "WithdrawRequestEvent": {
      "code": "event WithdrawRequestEvent(address indexed account, uint256 shares, uint16 round)",
      "inputs": {
        "account": {
          "type": "address",
          "indexed": true
        },
        "shares": {
          "type": "uint256",
          "indexed": false
        },
        "round": {
          "type": "uint16",
          "indexed": false
        }
      },
      "notice": "Emitted when user requests a withdrawal"
    }
  },
  "errors": {},
  "path": "/vaults",
  "notice": "Based on RibbonVault.sol         See https://docs.ribbon.finance/developers/ribbon-v2",
  "name": "ParetoVault"
}
