// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.6;

import {ABDKMath64x64} from "./ABDKMath64x64.sol";
import {CumulativeNormalDistribution} from "@primitivefi/rmm-core/contracts/libraries/CumulativeNormalDistribution.sol";
import {Units} from "@primitivefi/rmm-core/contracts/libraries/Units.sol";

/**
 * @notice Replication math useful for vaults
 */

library ReplicationMath {
    using ABDKMath64x64 for int128;
    using ABDKMath64x64 for uint256;
    using CumulativeNormalDistribution for int128;
    using Units for int128;
    using Units for uint256;

    int128 internal constant ONE_INT = 0x10000000000000000;
    int128 internal constant TWO_INT = 0x20000000000000000;

    /**
     * @notice Compute R1 = 1 - delta = 1 - N(d1). See Primitive whitepaper Sec 3.5
     * @dev Used when creating a new Primitive pool
     * @param spot is the spot price of risky asset in stable
     * @param strike is the strike price of risky asset in stable
     * @param sigma is the implied volatility (normalized)
     * @param tau is the expiry time T minus the current time t
     * @param scaleFactorStable is the unsigned 256-bit integer scaling factor for stable
     *  10^(18 - stable.decimals())
     * @param scaleFactorRisky is the scaling factor for risky assets
     */  
    function getRiskyPerLp(
        uint256 spot,
        uint256 strike,
        uint256 sigma,
        uint256 tau,
        uint256 scaleFactorStable,
        uint256 scaleFactorRisky
    ) internal pure returns (uint256 riskyForLp) {
        int128 d1;

        {
            int128 spotX64 = spot.scaleToX64(scaleFactorStable);
            int128 strikeX64 = strike.scaleToX64(scaleFactorStable);

            int128 tauX64 = tau.toYears();  /// @dev: Convert to years
            int128 sqrtTauX64 = tauX64.sqrt();
            int128 sigmaX64 = sigma.percentageToX64();
            int128 sigmaSqrX64 = sigmaX64.pow(2);

            int128 logRatioX64 = spotX64.div(strikeX64).ln();
            int128 crossTermX64 = tauX64.mul(sigmaSqrX64).div(TWO_INT);
            int128 volX64 = sigmaX64.mul(sqrtTauX64);

            d1 = logRatioX64.add(crossTermX64).div(volX64);
        }
        /// @dev: riskyForLpX64 spans between 0 and 1
        int128 riskyForLpX64 = ONE_INT.sub(d1.getCDF());

        // return in decimals of the risky asset
        // https://library.primitive.xyz/technical/smart-contracts/autogenerated-docs/manager/PrimitiveManager#create
        riskyForLp = riskyForLpX64.scaleFromX64(scaleFactorRisky);
        return riskyForLp;
    }
}
