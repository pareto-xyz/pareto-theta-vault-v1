// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.6;

import {ABDKMath64x64} from "./ABDKMath64x64.sol";
import {CumulativeNormalDistribution} from "@primitivefi/rmm-core/contracts/libraries/CumulativeNormalDistribution.sol";
import {Units} from "@primitivefi/rmm-core/contracts/libraries/Units.sol";
import {ReplicationMath} from "@primitivefi/rmm-core/contracts/libraries/ReplicationMath.sol";

/**
 * @notice Replication math used to compute `RiskyPerLp` and `StablePerLp`
 * @dev Useful link: https://toolkit.abdk.consulting/math#convert-number
 */
library MoreReplicationMath {
    using ABDKMath64x64 for int128;
    using ABDKMath64x64 for uint256;
    using CumulativeNormalDistribution for int128;
    using Units for int128;
    using Units for uint256;

    int128 internal constant ONE_INT = 0x10000000000000000;
    int128 internal constant TWO_INT = 0x20000000000000000;

    /**
     * @notice Used when creating a new Primitive pool. Compute `R1 = 1 - delta = 1 - N(d1)`
     * @dev See Primitive whitepaper Sec 3.5
     * @param spot Spot price of risky asset in stable
     * @param strike Strike price of risky asset in stable
     * @param sigma Implied volatility (normalized)
     * @param tau Expiry time T minus the current time t
     * @param scaleFactorRisky Unsigned 256-bit integer scaling factor for risky e.g. 10^(18 - risky.decimals())
     * @param scaleFactorStable Unsigned 256-bit integer scaling factor for stable e.g. 10^(18 - stable.decimals())
     */
    function getRiskyPerLp(
        uint256 spot,
        uint256 strike,
        uint256 sigma,
        uint256 tau,
        uint256 scaleFactorRisky,
        uint256 scaleFactorStable
    ) internal pure returns (uint256 riskyPerLp) {
        int128 d1;
        {
            // https://toolkit.abdk.consulting/math#convert-number
            int128 spotX64 = spot.scaleToX64(scaleFactorStable);
            int128 strikeX64 = strike.scaleToX64(scaleFactorStable);
            int128 tauX64 = tau.toYears(); /// @dev: Convert to years
            int128 sqrtTauX64 = tauX64.sqrt();
            int128 sigmaX64 = sigma.percentageToX64();
            int128 sigmaSqrX64 = sigmaX64.pow(2);
            int128 logRatioX64 = spotX64.div(strikeX64).ln();
            int128 crossTermX64 = tauX64.mul(sigmaSqrX64).div(TWO_INT);
            int128 volX64 = sigmaX64.mul(sqrtTauX64);
            d1 = logRatioX64.add(crossTermX64).div(volX64);
        }
        /// `riskyPerLpX64` spans between 0 and 1
        int128 riskyPerLpX64 = ONE_INT.sub(d1.getCDF());

        // Return in decimals of the risky asset
        // https://library.primitive.xyz/technical/smart-contracts/autogenerated-docs/manager/PrimitiveManager#create
        riskyPerLp = riskyPerLpX64.scaleFromX64(scaleFactorRisky);
        return riskyPerLp;
    }

    /**
     * @notice Compute `stableForLp` using Primitive's `ReplicationMath` library
     * @dev `stablePerLp = K*CDF(CDF^-1(1 - riskyPerLp) - sigma*sqrt(tau)) + invariantLastX64`
     *      This function is a wrapper around `ReplicatioMath.getStableGivenRisky`
     * @param invariantX64 Output of `PrimitiveEngine.invariantOf`
     * @param riskyPerLp Output of `MoreReplicationMath.getRiskyPerLp`
     * @param strike Strike price of risky asset in stable
     * @param sigma Implied volatility (normalized)
     * @param tau Expiry time T minus the current time t
     * @param scaleFactorRisky Unsigned 256-bit integer scaling factor for risky e.g. 10^(18 - risky.decimals())
     * @param scaleFactorStable Unsigned 256-bit integer scaling factor for stable e.g. 10^(18 - stable.decimals())
     */
    function getStablePerLp(
        int128 invariantX64,
        uint256 riskyPerLp,
        uint256 strike,
        uint256 sigma,
        uint256 tau,
        uint256 scaleFactorRisky,
        uint256 scaleFactorStable
    ) internal pure returns (uint256 stablePerLp) {
        stablePerLp = ReplicationMath.getStableGivenRisky(
            invariantX64,
            scaleFactorRisky,
            scaleFactorStable,
            riskyPerLp,
            strike,
            sigma,
            tau
        );
        return stablePerLp;
    }

    /**
     * @notice Compute strike price under Black-Scholes model given a chosen delta, 
     *         implied volatility, and spot price
     * @param delta Desired delta when deriving strike price (written as a percentage with 4 decimals)
     * @param spot Spot price of risky asset in stable
     * @param sigma Implied volatility (normalized)
     * @param tau Expiry time T minus the current time t
     * @param scaleFactorStable Unsigned 256-bit integer scaling factor for stable e.g. 10^(18 - stable.decimals())
     */
    function getStrikeGivenDelta(
        uint256 delta,
        uint256 spot,
        uint256 sigma,
        uint256 tau,
        uint256 scaleFactorStable
    ) internal pure returns (uint256 strike) {
        int128 strikeX64;
        {   
            int128 deltaX64 = delta.percentageToX64();
            int128 scoreX64 = deltaX64.getInverseCDF();

            int128 tauX64 = tau.toYears(); /// @dev: Convert to years
            int128 sigmaX64 = sigma.percentageToX64();
            int128 volX64 = sigmaX64.mul(tauX64.sqrt());
            int128 tauSigmaSqrX64 = tauX64.mul(sigmaX64.pow(2)).div(TWO_INT);
            int128 logitX64 = (tauSigmaSqrX64.sub(volX64.mul(scoreX64)));

            int128 spotX64 = spot.scaleToX64(scaleFactorStable);
            strikeX64 = spotX64.mul(logitX64.exp());
        }
        strike = strikeX64.scaleFromX64(scaleFactorStable);
        return strike;
    }
}
